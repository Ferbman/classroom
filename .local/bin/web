#!/usr/bin/env ruby
# frozen_string_literal: true

require 'ostruct'
require 'erb'
require 'singleton'
require 'fileutils'

require 'kramdown'
require 'htmlbeautifier'

BEGIN { Dir.chdir "#{__dir__}/../.." } # rubocop:disable Style/BeginBlock

module Page
  Error = Class.new StandardError

  class Config < OpenStruct
    include Singleton

    FILE = ".local/etc/#{File.basename($PROGRAM_NAME)}.yml"

    def initialize
      File.directory?(dir = File.dirname(FILE)) or (raise Error, "Config directory not found: #{dir}")
      File.exist?(FILE)                         or (raise Error, "Config file not found: #{FILE}")

      super YAML.load_file(FILE)
    end
  end

  module Utils
    module_function

    def icon(icon, url, text = nil)
      prefix = text ? "#{text} " : ''

      return %{#{prefix}[<i data-feather="#{icon}"></i>](#{url})} if url && !url.empty?

      %(#{prefix}<i data-feather="x"></i>)
    end
  end

  class Base
    FRONTMATTER_PATTERN = /---(.|\n)*---/.freeze
    INDEX_HTML          = 'index.html'

    class << self
      def match?(path)
        path =~ pattern && File.exist?(File.join(path, indexfile))
      end

      def pattern
        /^[^.]/.freeze
      end

      def indexfile
        'index.md'
      end

      def template
        Config.instance.public_send name.split('::').last.downcase
      end
    end

    attr_reader :slug, :var, :children

    def initialize(dir)
      @slug     = dir.delete_prefix('./')
      @children = []

      load
    end

    def load
      @body, @var =
        case (hash = YAML.safe_load(body = File.read(self.class.indexfile)))
        when ::Hash then [body.gsub(FRONTMATTER_PATTERN, '').strip, OpenStruct.new(hash)]
        else             [body, OpenStruct.new]
        end

      scan
    end

    def title
      @title ||= var.title || body.split("\n").first.chomp.gsub(/^#+\s+/, '')
    end

    def name
      @name ||= File.basename slug
    end

    def html
      Kramdown::Document.new(erb(self.class.template)).to_html
    rescue Kramdown::Error => e
      raise Error, "Markdown error: #{e.message}"
    end

    def css
      Config.instance.respond_to?(:css) ? Config.instance.css : ''
    end

    def render
      HtmlBeautifier.beautify(erb(Config.instance.layout))
    end

    def renderable?
      true
    end

    def generate(outdir, filename = INDEX_HTML)
      FileUtils.mkdir_p File.dirname(file = File.join(outdir, slug, filename))
      File.write file, render
    end

    private

    attr_reader :body

    def scan
      return unless self.class.respond_to?(:child) && (child = self.class.child)

      Dir['*'].each do |dir|
        next unless File.directory?(dir) && child.match?(dir)

        Dir.chdir(dir) { children << child.new(File.join(slug, dir)) }
      end
    end

    def erb(template)
      ERB.new(template, trim_mode: '-', eoutvar: '_erbout').result(_binding)
    rescue StandardError => e
      raise Error, "Template render error: #{e.message}"
    end

    def _binding
      binding
    end
  end

  class Root < Base
    def self.child
      Course
    end
  end

  class Course < Base
    PDF = 'slides.pdf'

    def self.child
      Lecture
    end

    def pdf
      PDF
    end

    def audience
      var.audience
    end

    def to_s
      "#{title} / #{audience}"
    end
  end

  class Lecture < Base
    INDEX = 'README.md'

    def self.pattern
      /^[1-2]\d{3}[ _-]+/.freeze
    end

    def self.indexfile
      INDEX
    end

    def title
      name.tr('_', ' ')
    end

    def date
      title
    end

    def notes
      File.join Config.instance.repository, 'tree', 'HEAD', slug
    end

    def recording
      var.respond_to?(:recording) and var.recording
    end

    def renderable?
      false
    end
  end

  class << self
    def generate(root: '.', outdir: '.local/tmp')
      visit Page::Root.new(root) do |page|
        next unless page.renderable?

        page.generate(outdir)
      end

      FileUtils.touch File.join(outdir, '.nojekyll')
    end

    private

    def visit(root, &block)
      yield(root)

      root.children.each do |child|
        visit(child, &block)
      end
    end
  end
end

def main
  Page.generate outdir: ARGV.first || 'tmp'
rescue Page::Error => e
  abort e.message
end

main
